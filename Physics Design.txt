class Entity
{
members:
	-position as vec3
	-rotation as YPR
	-accel as vec3
	-velocity as vec3
functions:
	ctor(pos, rot = 0,0,0, vel = 0,0,0, accel = 0,0,0)

	virtual void tick(float elapsed_time)
	{
		vel += accel * elapsed_time;
		pos += velocity * elapsed_time;
	}
	
	gets/sets()
}

class Renderable : public Entity
{
members:
	-Mesh as render DLL mesh
	-Scale as vec3
functions:
	ctor(mesh, pos, scale = 1,1,1, rot = 0,0,0, vel = 0,0,0, accel = 0,0,0)

	gets/sets()
}

class PhysicsObject : public Renderable 
{
members:
	-Collision Mesh as CollisionMesh
	-Material as Materal
	-mass as float
	-canCollide as boolean
	-canGravity as boolean
	-collisionflags as 8 bit thing
	-vector of collided physicsobjects as vector
functions:
	ctor(mass, Material, mesh, pos, canGravity = true, canCollide = true, scale = 1,1,1, rot = 0,0,0, vel = 0,0,0, accel = 0,0,0)


	virtual void tick(float elapsed_time) override
	{
		vel.y += getWorld()->getGravity() * elapsed_time;
		Entity::tick(elapsed_time);
	}

	virtual void checkCollision()
	{
		find object i collide with
		if there are any add them to the collided list
	}

	virtual void resolveCollisions()
	{
		go thru collided objects and resolve this and the collider
	}

	gets/sets()

}

struct Material
{
	float collisionTime;
	float friction;
}
	add a layer!!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~

void run()
{

	int calltime = curtime
	while(running)
	{
		elapsed = curtime - calltime
		calltime = curtime;
		wake up physics
		wake up render
		sleep(amt);
	}
}

void renderThread()
{
	vector<Renderable> aa = core_getRenderables();
	for(int a=0;a<aa.size();a++)
	{
		render(aa.getMesh());
	}

	render those meshes
}

void physicsThread()
{
	call tick for every entity in entitylist regardless of type, pass elapsed time
	check collisions
	resolve collisions
}